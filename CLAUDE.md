# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

FastAPI + SQLModel skeleton for a draft analytics app. Uses async SQLAlchemy with PostgreSQL (asyncpg driver), Alembic for migrations, and pytest for testing.

## Essential Commands

### Running the Application
```bash
# Development with auto-reload
make dev

# Production-like (no reload)
make run

# Override host/port
HOST=127.0.0.1 PORT=9000 make dev

# Direct uvicorn invocation
python -m uvicorn app.main:app --reload
```

### Database Migrations
```bash
# Upgrade to latest revision
make mig.up

# Create new migration (autogenerate)
make mig.revision m="describe change"

# View migration history
make mig.history

# Show current revision
make mig.current

# Revert last migration (use with care)
make mig.down

# Direct Alembic commands
alembic revision --autogenerate -m "message"
alembic upgrade head
alembic downgrade -1
```

### Testing
```bash
# Run tests (requires PYTEST_ALLOW_DB=1 and TEST_DATABASE_URL)
export TEST_DATABASE_URL="postgresql+asyncpg://user:pass@host:5432/draftguru_test"
export PYTEST_ALLOW_DB=1
pytest

# Run specific test
pytest tests/test_players.py::test_create_player
```

### Linting & Type Checking
```bash
# Ruff (linter)
ruff check .

# Mypy (type checker)
mypy app/

# Pre-commit hooks
pre-commit run --all-files
```

### Environment Setup
```bash
# Create conda environment
conda env create -f environment.yml
conda activate draftguru

# Or use pip
pip install -e .[dev]  # includes dev dependencies
```

## Architecture

### Module Organization

The codebase separates **request/response models** from **database tables**:

- **`app/models/`**: Pydantic/SQLModel classes for API request/response schemas (`PlayerBase`, `PlayerCreate`, `PlayerRead`)
  - These define validation logic, computed fields, and field validators
  - `app/models/fields.py` contains shared field types and custom enums

- **`app/schemas/`**: SQLModel table definitions with `table=True` (`PlayerTable`)
  - These are the canonical schema that Alembic inspects for migrations
  - Inherit from models in `app/models/` for shared validation
  - `app/schemas/base.py` contains mixins like `SoftDeleteMixin`

This separation prevents overposting and keeps response shapes stable while allowing shared validation logic.

### Database Architecture

- **Async-first**: Uses SQLAlchemy async engine with asyncpg driver
- **Connection handling**: `app/utils/db_async.py` manages engine lifecycle and normalizes database URLs
  - Strips unsupported asyncpg query parameters (`channel_binding`)
  - Handles SSL modes (`sslmode=require`, `verify-ca`, `verify-full`)
  - `load_schema_modules()` ensures all table definitions are imported before metadata operations

- **Schema auto-discovery**: Both `app/utils/db_async.py` and `alembic/env.py` use `pkgutil.walk_packages()` to import all modules in `app/schemas/`, ensuring SQLModel metadata captures all tables

- **Lifespan management** (`app/main.py`):
  - `init_db()` creates tables at startup when `AUTO_INIT_DB=true` and `ENV=dev` (disabled on Fly deployments)
  - Engine disposed cleanly on shutdown

### Testing Architecture

- **Integration tests**: Target real Postgres database (requires `PYTEST_ALLOW_DB=1` guard flag)
- **Fixtures** (`tests/conftest.py`):
  - Session-scoped `async_engine` creates/drops all tables once per test run
  - Function-scoped `db_session` provides clean transactional isolation per test
  - `app_client` overrides `get_session` dependency to inject test session into routes
- **Asyncio config** (`pytest.ini`): Uses `asyncio_mode=strict` with session-scoped event loops

### Migration Strategy

**When to create migrations:**
- **New tables**: Use `SQLModel.metadata.create_all(bind=..., tables=[MyTable.__table__])` in upgrade (and `drop_all` in downgrade)
- **Existing tables**: Keep Alembic's autogenerated `op.*` statements (`op.add_column`, `op.alter_column`, etc.)
- Never drop/recreate production tables just to change columns

**Migration workflow:**
1. Add or modify table definitions in `app/schemas/`
2. Run `make mig.revision m="description"` to autogenerate migration
3. Review generated migration file carefully
4. Test migration on disposable database: `make mig.up`, verify schema, then `alembic downgrade base`
5. Commit migration file with schema changes

**Important:** Alembic auto-imports all `app/schemas/` modules via `alembic/env.py`, so new tables are automatically discovered.

### Configuration

- **Settings class** (`app/config.py`): Pydantic Settings model loads from `.env`
  - Required: `DATABASE_URL`, `SECRET_KEY`
  - Optional: `ENV` (dev/stage/prod), `DEBUG`, `LOG_LEVEL`, `ACCESS_LOG`, `SQL_ECHO`, `AUTO_INIT_DB`
- **Database URL normalization**: Automatically converts `postgres://` or `postgresql://` to `postgresql+asyncpg://`
- **Never commit secrets**: Use `.env` (gitignored) for local config

## Commit Style

Follow Conventional Commits format observed in git history:
- `feat:` - new features
- `fix:` - bug fixes
- `chore:` - maintenance tasks
- `ci:` - CI/CD changes
- `style:` - formatting/linting
- `test:` - test additions/fixes
- `build:` - dependency updates

Keep subject lines under 72 characters.
